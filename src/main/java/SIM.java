import java.util.ArrayList;
import java.util.List;

/**
 * Simple strategy to deal with TSP problem
 * Using Nearest Neighbor Method
 */
public class SIM extends TSP{

    int[][] costs;

    public SIM(int n, String costFunction, int MEB){
        this.n = n;
        this.costFunction = costFunction;
        this.MEB = MEB;
        strategy = "SIM";
    }

    /**
     * Generate a Tour starts from a city
     * At each step, choose the nearest neighbor of current city
     * @param start : the start point of the Tour
     * @return
     */
    public Tour generateTSP(int start){
        int current = start;
        List<Integer> visited = new ArrayList<>();
        int cost = 0;
        visited.add(current);

        while(visited.size() < n && steps < MEB){
            int minCost = Integer.MAX_VALUE;
            int nearestID = current;
            for(int j = 0; j < n; j++){
                if(!visited.contains(j)){
                    if(costs[current][j] < minCost){
                        minCost = costs[current][j];
                        nearestID = j;
                    }
                }
            }
            visited.add(nearestID);
            steps++;
            cost += minCost;
            current = nearestID;
        }
        cost += costs[current][start];
        return new Tour(visited, cost);
    }

    @Override
    /**
     * Choose each city as start point and generate a Tour for each start point using Nearest Neighbor Method
     * Calculate costs for all Tours and return the Tour with minimum cost
     */
    public Tour findMinTSP(){

        //costs[i][j] denotes the cost from city i to city j
        costs = Cost.generateCosts(n, costFunction);

        int minTotalCost = Integer.MAX_VALUE;
        Tour result = new Tour(n);

        for(int i = 0; i < n; i++){
            Tour tour = generateTSP(i);

            /*
            we should check the size of Tour because there are two stop condition in generateTSP() method;
            if steps == MEB while the tour is not complete, we should not consider this tour
            */
            if(tour.getCost() < minTotalCost && tour.getTour().size() == n){
                result = tour;
                minTotalCost = tour.getCost();
            }
        }
        return result;
    }

    @Deprecated
    public void printResult(Tour tour){

        System.out.println("TSP of " + n + " nodes with cost function " + costFunction + " Generated By SIM:");
        System.out.println(tour);
        System.out.println("Cost : " + tour.getCost());
    }

    @Deprecated
    public void printArray(){
        for(int i = 0; i < costs.length; i++){
            for(int j = 0; j < costs[0].length; j++){
                System.out.printf("%5d", costs[i][j]);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) throws Exception{
        SIM sim = new SIM(60, "c1", 100000);
        Tour resultTour = sim.findMinTSP();
        sim.printArray();
        System.out.println("Total Steps: " + sim.steps);
        sim.printResult(resultTour);

    }
}
